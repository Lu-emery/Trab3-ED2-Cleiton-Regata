===================================================================================
Relatório Referente ao Terceiro Trabalho de Implementação de Estrutura de Dados 2
                                  2018/2

                                  Alunos:
                    Lucas Mendonça Emery Cade (2017100210)
                    Lucas Moraes Soares de Souza (2016101245)
====================================================================================

SO utilizado: Windows 10 com subsystem Ubuntu 16.04
Versão do compilador utilizado:
Editor(es) de código utilizado(s): Atom

/******************************************************************************
 *  Especificações de arquivos.
 *****************************************************************************/
Pasta "Versão Funcional"
	Versão que funciona em todos os tamanhos, mas tem tempo indeterminado para
		C >= 8
		
		Para executar, usar "make decrypt" e executar "./decrypt [passw] < ../in/[tabela].txt"


	Nessa pasta, também se encontra a versão brute force do problema
		Para executar, usar "make brute" e executar "./brute [passw] < ../in/[tabela].txt"


Pasta "Versão Protótipo"
	Versão que funciona somente para C <= 6, mas tem tempo ótimo para a busca
		(e inevitável falha) mesmo em C >= 8
		
		Para executar, usar "make decrypt" e executar "./decrypt [passw] < ../in/[tabela].txt"

/******************************************************************************
 *  Se você usou o arquivo key.c, descreva qualquer modificação/otimização que
 *  você tenha feito no código. Se você não utilizou key.c, descreva a
 *  estrutura de dados que você utilizou para manipular as senhas.
 *****************************************************************************/
Adicionamos ao key.c uma função de comparação de chaves que retorna:
* 1 caso as chaves sejam iguais;
* 0 caso contrario.

/******************************************************************************
 *  Descreva a sua solução força bruta (brute.c)
 *****************************************************************************/
1 Converte a entrada em uma Key
2 Cria uma String com o tamanho C+1 para que possa comportar
    o uma palavra do tamanho atual do C mais o '\0'
3 Lê a tabela de encriptação, a converte para Keys e armazena
    as mesmas no vetor T
4 Gera recursivamente todas as palavras possíveis baseando-se
    em "ALPHABET". (função geradorPalavra)
    4.1 Cada loop percorre todos os caracteres possíveis, porém
        quando o tamanho da palavra alcança C-1 sabe-se que não
        se pode colocar outro caracter e inicia-se o brute.
        Assim todas as possíveis palavras são geradas.
5 Recebe como parâmetro uma palavra a ser encriptada, converte
    a mesma para Key e a encripta. Depois, na mesma função, se
    compara a encriptação gerada com a entrada do programa, caso
    elas sejam iguais se printa a palavra referente a encriptação
    válida.

/******************************************************************************
 *  Faça uma descrição de alto nível do seu programa de quebra de senha
 *  (decrypt.c).
 *****************************************************************************/
1 Converte a entrada em uma Key
2 Cria uma String com o tamanho C+1 para que possa comportar
    o uma palavra do tamanho atual do C mais o '\0'
3 Lê a tabela de encriptação, a converte para Keys e armazena
    as mesmas no vetor T (função leituraTabela)
4 Cria a matriz que irá armazenar todas as somas referentes a
    cada caractere em posições específica.(função somaCaracteres)
    TSomas[posição do caractere][caractere]
5 Cria tabela de combinações.(função criaTabela)
    5.1 Caso o número de caracteres seja menor ou igual a 5
    cria-se uma tabela de combinações de tamanho C-1.
    5.2 Caso o número de caracteres seja maior que 5 cria-se
    uma tabela de combinações igual a 5 em todos os casos, dessa
    forma otimizasse o tempo para valores grandes pre-computando
    uma parte das possibilidades.
6 Define todas as possíveis possibilidades que possam ser geradas
    com o número dado de caracteres e consultando as combinações
    já pre-computadas(função weakComTabela). Ao final de cada iteração
    é checado se a encriptação gerada é a mesma que a dada como entrada.
7 Libera o espaço usado pela tabela de combinações.

/******************************************************************************
 *  Descreva a implementação da tabela de símbolos que você utilizou em
 *  decrypt.c .
 *****************************************************************************/
1 Cria key auxiliar vazia
2 Para cada iteração do "for" um caractere diferente é somado na função
    Tabela que possui os caracteres TSomas[posição do caractere][caractere]
3 Preenche recursivamente a tabela de combinações, usando a recursão como
    pilha para melhorar o desempenho.
4 Retorna tabela com todas as combinações possíveis de 5 caracteres (caso base)
    "aaaaa", "aaaaab", ..., "aaaa5", "aaaba", ..., "baaaa", ..., "55555"


/******************************************************************************
 *  Liste abaixo as versões não criptografadas das senhas fornecidas na
 *  especificação do trabalho. Faça isso SOMENTE se você foi capaz de quebrar
 *  as senhas usando o SEU código.
 *****************************************************************************/

O código funcional que quebra senhas acima de 6 caracteres demora uma quantidade
de tempo indeterminada para C >= 8 .

O código que executa em tempo hábil não gera senhas acima de 6 caracteres.

Logo, não temos dados das respostas.

8 caracteres         10 caracteres          12 caracteres
------------         -------------          -------------


/******************************************************************************
 *  Quanto tempo a versão força bruta leva para quebrar as senhas de um dado
 *  tamanho? Forneça estimativas com um asterisco se o programa levar mais do
 *  que a sua paciência (por exemplo, um ou dois minutos). Justifique as suas
 *  estimativas.
 *****************************************************************************/

Tamanho     Tempo (segundos)
----------------------------
 4              3.318s
 5            226.318s
 6			       >15 min  (Estimativa)
 8             >1h      (Estimativa)

Pode-se usar o número de operações descrito abaixo, multiplicado por uma estimativa
do tempo de cada operação utilizada para gerar uma estimativa mais aproximada do tempo
de execução.


/******************************************************************************
 *  Quanto tempo decrypt.c leva para quebrar as senhas de um dado tamanho?
 *  Quanto de memória o programa utiliza? Forneça estimativas com um asterisco
 *  se o programa levar mais que a sua paciência ou utilizar mais memória que
 *  o seu sistema possui. Justifique as suas estimativas.
 *****************************************************************************/

Tamanho    Tempo (segundos)    Memória (bytes)
----------------------------------------------
 6          201.645s(3m21s)         1Gb*
 8             >1h                  1Gb*
10           não testado            1Gb*
12           não testado            1Gb*

*Para cada exemplo acima de 5 caracteres, o programa faz uma tabela de símbolos
  referente a cada combinação possível de 5 caracteres.

  Logo, o tamanho da tabela é 32^5(33.554.432) chaves
  Cada chave tem 5 caracteres de 5 bits, logo, a tabela tem 33.554.432*5*5(838.860.800) bits
  Que equivale a aprox. 0,838 GB de RAM em uso pelo programa

  O gerenciador de tarefas (executado na tarefa de tamanho 8) mostra um gasto de 1,28 GB de RAM
  a diferença causada por outros dados armazenados em tempo de execução
  (como a tabela de valores de caracteres individuais e a tabela T)
/******************************************************************************
 *  Quantas operações brute.c faz sobre uma senha com N bits?
 *  Quantas operações decrypt.c faz sobre uma senha com N bits?
 *  Utilize a notação de big-Oh nas suas respostas.
 *****************************************************************************/

brute:
Nº de chamadas de geradorPalavra(): R^C
	            Operações em brute(): (N*C)+2C+C

Resultado:  (R^C)*(N*C+2C+C);
	Sendo:  C = número de caracteres de uma senha
			    R = tamanho do alfabeto (32)
			    N = número de bits de uma senha

decrypt:
     Operações para gerar a tabela: (R^5)*(N*5+15)
Operações com os outros caracteres: R^(C-5) * T

Resultado: (R^5)(N*5+15) + ((R^(C-5)) * T)
  Sendo: C = número de caracteres de uma senha
         R = tamanho do alfabeto
         T = número de combinações da tabela gerada


/******************************************************************************
 *  Descreva qualquer problema grave que você encontrou ao desenvolver
 *  o trabalho.
 *****************************************************************************/
Durante as primeiras tentativas de resolver o problema da tabela de símbolos,
tivemos a ideia de implementar uma árvore binária de busca que diminuiria recursivamente
o valor de um nó do valor 'pass' a ser encontrado e economizaria testes nos filhos
da sub-árvore de elementos maiores que o 'pass' atual.

Essa ideia se provou interessante e passamos dois dias debatendo e escrevendo projetos
de código para tentar implementá-la.

Descobrimos, depois de gastar esse tempo na possível solução, que a operação de soma era
feita com o valor absoluto e ignorava módulo que fazia resultados maiores que 32, invalidando completamente a solução proposta.

O tempo dedicado ao trabalho foi outro ponto importante, visto que nas primeiras semanas
após ele ter sido passado, o tempo de desenvolvimento dele teve que ser dividido com o segundo
trabalho de implementação de Programação III (em C++) e na última semana antes da entrega, os componentes
do grupo tiveram 3 e 4 provas, respectivamente.

Pela falha na implementação inicial e o tempo limitado, não foi possível trabalhar na solução
que foi implementada com sucesso para reduzir o tempo de execução de forma consideravel.

Também tivemos a ideia de trabalhar novamente com a subtração do valor 'pass' de cada chave
no brute-force parcial feito na tabela de símbolos e fazer a busca na tabela pelo valor resultante,
tirando a necessidade de percorrer a totalidade da tabela sempre que um valor fosse ser testado.

O código resultante tem tempos de execução ótimos em todos os casos, mas não gera resultados a partir
do caso C = 8. Assumimos que é uma limitação daa função "sub(Key a, Key b)" implementada.

Esse código se encontra na pasta "Versão Protótipo"

/******************************************************************************
 *  Deixe qualquer outro comentário aqui. Fique à vontade para dar um feedback
 *  sobre o quanto você acha que aprendeu com esse trabalho, e se você gostou
 *  de fazê-lo.
 *****************************************************************************/
 O trabalho foi bastante difícil, talvez pela mudança na metodologia de não procurar
 uma solução específica, mas de ter que bolar uma solução quase que a partir do zero.
 Mas essa mesma mudança de metodologia foi bastante interessante, e fez os alunos pensarem mais
 e discutirem entre si para tentar chegar em alguma(s) soluções.
 Em sumo, foi um trabalho divertido de implementar, mesmo com muitas frustrações no meio do caminho.
                                                                                -Lucas Emery

 Esse trabalho representou sem sombra de dúvidas o maior desafio do semestre. Cada tentativa de resolve-lo
 esclareceu mais varias dúvidas sobre o problema, percebo que é um trabalho que exigem mais dedicação e
 imaginção do que qualquer outro que tenha sido apresentado na faculdade até o semestre em que estou.
 Considero uma boa a abordagem do problema e o desafio que ele representa. Por fim, me sinto mais resiliente e
 pronto a enfrentar desafios maiores.

                                                                                -Lucas Moraes
